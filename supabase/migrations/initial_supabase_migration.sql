-- =============================================================
-- ИТОГОВАЯ МИГРАЦИЯ ДЛЯ НОВОЙ БАЗЫ (Supabase / PostgreSQL)
-- Назначение: создать все объекты (расширения, таблицы, индексы,
-- RLS-политики, функции и триггеры) для работы дашборда и загрузки отчётов.
-- Подробные комментарии включены к каждому блоку.
-- Скрипт рассчитан на запуск в чистой БД (idempotency частично соблюдён).
-- =============================================================

-- =============================================================
-- 1) РАСШИРЕНИЯ
-- -------------------------------------------------------------
-- Требуются:
-- - pgcrypto: функция gen_random_uuid() для генерации UUID.
-- - vector: тип vector(1024) для семантического поиска (pgvector).
-- В Supabase эти расширения, как правило, доступны.
-- =============================================================
create extension if not exists pgcrypto;
create extension if not exists vector;

-- =============================================================
-- 2) ТАБЛИЦЫ ОСНОВНОГО ЯДРА
-- -------------------------------------------------------------
-- Сущности:
--   organizations           — организации (клиенты/группы компаний).
--   organization_members    — пользователи и их роли в организациях.
--   report_metadata         — метаданные отчётов по датам и типам.
--   *_report_items          — строки отчётов (иерархические деревья).
--   *_monthly_summaries     — агрегированные месячные сводки.
-- -------------------------------------------------------------
-- Важно: все внешние ключи с каскадным удалением; report_id NOT NULL.
-- =============================================================

-- Организации
create table if not exists public.organizations (
  id uuid primary key default gen_random_uuid(),
  name text not null unique,
  external_id text unique
);

-- Членство пользователей в организациях
create table if not exists public.organization_members (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  organization_id uuid not null references public.organizations (id) on delete cascade,
  role text not null check (role in ('admin', 'member')),
  created_at timestamptz default now(),
  unique (user_id, organization_id)
);

-- Метаданные отчётов (тип + дата)
create table if not exists public.report_metadata (
  id uuid primary key default gen_random_uuid(),
  organization_id uuid not null references public.organizations (id) on delete cascade,
  report_type text not null,   -- допустимые значения задаются на уровне приложений
  report_date date not null,
  created_at timestamp default now(),
  updated_at timestamp,
  unique (organization_id, report_type, report_date)
);

-- Отчёт: Денежные средства (банк/касса)
create table if not exists public.cash_bank_report_items (
  id uuid primary key default gen_random_uuid(),
  report_id uuid not null references public.report_metadata (id) on delete cascade,
  subconto text,
  account_name text not null,
  balance_start decimal(15, 2),
  income_amount decimal(15, 2),
  expense_amount decimal(15, 2),
  balance_current decimal(15, 2),
  account_type text check (account_type in ('bank', 'cash', 'total')),
  level integer,
  currency text not null,
  is_total_row boolean default false,
  created_at timestamptz default now() not null,
  -- Иерархия
  parent_id uuid references public.cash_bank_report_items (id) on delete set null,
  account_id text,
  parent_account_id text
);

-- Отчёт: Товарные запасы / оборачиваемость
create table if not exists public.inventory_turnover_report_items (
  id uuid primary key default gen_random_uuid(),
  report_id uuid not null references public.report_metadata (id) on delete cascade,
  category_name text not null,
  parent_category_id uuid references public.inventory_turnover_report_items (id) on delete set null,
  quantity_pairs integer,
  balance_rub decimal(15, 2),
  dynamics_start_month_rub decimal(15, 2),
  dynamics_start_month_percent decimal(5, 2),
  dynamics_start_year_rub decimal(15, 2),
  dynamics_start_year_percent decimal(5, 2),
  turnover_days integer,
  level integer,
  is_total_row boolean default false
);

-- Отчёт: Дебиторка/кредит (задолженности)
create table if not exists public.debt_reports_items (
  id uuid primary key default gen_random_uuid (),
  report_id uuid not null references public.report_metadata (id) on delete cascade,
  debt_amount numeric not null,
  overdue_amount numeric not null,
  credit_amount numeric not null,
  is_total_row boolean default false not null,
  client_name text not null,
  parent_client_id uuid references public.debt_reports_items (id) on delete set null,
  created_at timestamptz default now(),
  level int
);

-- Отчёт: План-факт
create table if not exists public.plan_fact_reports_items (
  id uuid primary key default gen_random_uuid (),
  report_id uuid not null references public.report_metadata (id) on delete cascade,
  plan_amount numeric not null,
  fact_amount numeric not null,
  execution_percent numeric not null,
  is_total_row boolean default false not null,
  created_at timestamptz default now() not null,
  -- Иерархия и метаданные
  category_name text,
  parent_id uuid references public.plan_fact_reports_items (id) on delete set null,
  period_type text,     -- допустим: 'day' | 'month' | 'year' (на стороне приложения)
  level integer,
  is_expandable boolean
);

-- Месячные сводки (агрегаты, наполняются доверенным бэкендом)
create table if not exists public.cash_bank_monthly_summaries (
  organization_id uuid not null references public.organizations (id) on delete cascade,
  year integer not null check (year between 1900 and 2100),
  month integer not null check (month between 1 and 12),
  account_type text not null,
  avg_balance decimal(15, 2),
  total_income decimal(15, 2),
  total_expense decimal(15, 2),
  primary key (organization_id, year, month, account_type)
);

create table if not exists public.inventory_monthly_summaries (
  organization_id uuid not null references public.organizations (id) on delete cascade,
  year integer not null,
  month integer not null,
  category_path text,
  avg_balance_rub decimal(15, 2),
  avg_turnover_days integer,
  primary key (organization_id, year, month, category_path)
);

create table if not exists public.debt_monthly_summaries (
  organization_id uuid references public.organizations (id) on delete cascade,
  year int not null,
  month int not null,
  client_name text not null,
  total_debt numeric not null,
  total_overdue numeric not null,
  total_credit numeric not null,
  primary key (organization_id, year, month, client_name)
);

create table if not exists public.plan_fact_monthly_summaries (
  organization_id uuid references public.organizations (id) on delete cascade,
  year int not null,
  month int not null,
  category_name text not null,
  total_plan numeric not null,
  total_fact numeric not null,
  execution_percent numeric not null,
  primary key (organization_id, year, month, category_name)
);

-- Индексы (точечно — по часто используемым полям)
create index if not exists idx_debt_reports_items_report_id on public.debt_reports_items using btree (report_id);
create index if not exists idx_debt_reports_items_client_name on public.debt_reports_items using btree (client_name);
create index if not exists idx_debt_reports_items_parent_client_id on public.debt_reports_items using btree (parent_client_id);
create index if not exists idx_debt_reports_items_level on public.debt_reports_items using btree (level);

-- =============================================================
-- 3) ТАБЛИЦЫ ДЛЯ ВСПОМОГАТЕЛЬНЫХ ФУНКЦИЙ (RAG, ЧАТБОТ)
-- -------------------------------------------------------------
-- documents         — RAG-хранилище с эмбеддингами.
-- usersbot          — вспомогательная таблица «пользователей» бота.
-- n8n_chat_histories— журнал сообщений (интеграции).
-- =============================================================

create table if not exists public.documents (
  id bigserial primary key,
  content text,
  metadata jsonb,
  embedding vector(1024)
);

create table if not exists public.usersbot (
  user_id bigint primary key,
  user_name text,
  user_pass text,
  user_secret text,
  user_format text,
  is_subscribed boolean default false
);

create table if not exists public.n8n_chat_histories (
  id bigint generated by default as identity primary key,
  session_id varchar not null,
  message jsonb not null,
  created_at timestamptz not null default now()
);

-- =============================================================
-- 4) ФУНКЦИИ-ПОМОЩНИКИ ДЛЯ RLS
-- -------------------------------------------------------------
-- is_member_of / is_admin_of            — проверка статуса участия/админа.
-- is_organization_empty / is_last_admin — служебные проверки для политик.
-- SECURITY DEFINER и STABLE там, где уместно.
-- =============================================================

create or replace function public.is_member_of(p_organization_id uuid, p_user_id uuid)
returns boolean language sql security definer stable as $$
  select exists (
    select 1 from public.organization_members om
    where om.organization_id = p_organization_id and om.user_id = p_user_id
  );
$$;

create or replace function public.is_admin_of(p_organization_id uuid, p_user_id uuid)
returns boolean language sql security definer stable as $$
  select exists (
    select 1 from public.organization_members om
    where om.organization_id = p_organization_id and om.user_id = p_user_id and om.role = 'admin'
  );
$$;

create or replace function public.is_organization_empty(p_organization_id uuid)
returns boolean language sql security definer stable as $$
  select not exists (select 1 from public.organization_members om where om.organization_id = p_organization_id);
$$;

create or replace function public.is_last_admin_in_organization(p_organization_id uuid, p_user_id uuid)
returns boolean language plpgsql security definer as $$
declare
    admin_count integer;
    is_user_an_admin boolean;
begin
    select exists (
        select 1 from public.organization_members om
        where om.organization_id = p_organization_id and om.user_id = p_user_id and om.role = 'admin'
    ) into is_user_an_admin;

    if not is_user_an_admin then
        return false;
    end if;

    select count(*) into admin_count from public.organization_members om
    where om.organization_id = p_organization_id and om.role = 'admin';

    return admin_count = 1;
end;
$$;

-- =============================================================
-- 5) ВКЛЮЧЕНИЕ RLS И ПОЛИТИКИ ДОСТУПА
-- -------------------------------------------------------------
-- Таблицы-источники данных и агрегаты доступны только участникам
-- соответствующих организаций. Запись/изменение — только для админов.
-- Сводные месячные таблицы делаем read-only для клиентов API.
-- =============================================================
-- organization_members
alter table public.organization_members enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Users can view their own membership record.'
          AND schemaname = 'public'
          AND tablename = 'organization_members'
    ) THEN
        CREATE POLICY "Users can view their own membership record."
        ON public.organization_members
        FOR SELECT
        USING (user_id = auth.uid());
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Admins can add members; users can join a new org.'
          AND schemaname = 'public'
          AND tablename = 'organization_members'
    ) THEN
        CREATE POLICY "Admins can add members; users can join a new org."
        ON public.organization_members
        FOR INSERT
        WITH CHECK (
          (public.is_admin_of(organization_members.organization_id, auth.uid())) OR
          (organization_members.user_id = auth.uid() AND public.is_organization_empty(organization_members.organization_id))
        );
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Admins can update member roles in their organization.'
          AND schemaname = 'public'
          AND tablename = 'organization_members'
    ) THEN
        CREATE POLICY "Admins can update member roles in their organization."
        ON public.organization_members
        FOR UPDATE
        USING (public.is_admin_of(organization_id, auth.uid()))
        -- В RLS нельзя ссылаться на OLD/NEW.
        -- USING применяется к старой строке, WITH CHECK — к новой.
        -- Блокируем понижение последнего админа: разрешаем апдейт, если
        -- (а) в организации есть другой админ ИЛИ (б) новая роль остаётся 'admin'.
        WITH CHECK (
          (NOT public.is_last_admin_in_organization(organization_id, user_id))
          OR (role = 'admin')
        );
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Admins can remove members, and users can remove themselves.'
          AND schemaname = 'public'
          AND tablename = 'organization_members'
    ) THEN
        CREATE POLICY "Admins can remove members, and users can remove themselves."
        ON public.organization_members
        FOR DELETE
        USING (
          (public.is_admin_of(organization_members.organization_id, auth.uid()) OR (organization_members.user_id = auth.uid())) AND
          (NOT public.is_last_admin_in_organization(organization_members.organization_id, organization_members.user_id))
        );
    END IF;
END
$$;

-- report_metadata
alter table public.report_metadata enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read their organization''s report metadata'
          AND schemaname = 'public'
          AND tablename = 'report_metadata'
    ) THEN
        CREATE POLICY "Allow members to read their organization's report metadata"
        ON public.report_metadata
        FOR SELECT
        USING (public.is_member_of(report_metadata.organization_id, auth.uid()));
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow admins to manage report metadata'
          AND schemaname = 'public'
          AND tablename = 'report_metadata'
    ) THEN
        CREATE POLICY "Allow admins to manage report metadata"
        ON public.report_metadata
        FOR ALL
        WITH CHECK (public.is_admin_of(report_metadata.organization_id, auth.uid()));
    END IF;
END
$$;

-- cash_bank_report_items
alter table public.cash_bank_report_items enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read cash/bank items'
          AND schemaname = 'public'
          AND tablename = 'cash_bank_report_items'
    ) THEN
        CREATE POLICY "Allow members to read cash/bank items"
        ON public.cash_bank_report_items
        FOR SELECT
        USING (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = cash_bank_report_items.report_id
              AND public.is_member_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow admins to manage cash/bank items'
          AND schemaname = 'public'
          AND tablename = 'cash_bank_report_items'
    ) THEN
        CREATE POLICY "Allow admins to manage cash/bank items"
        ON public.cash_bank_report_items
        FOR ALL
        WITH CHECK (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = cash_bank_report_items.report_id
              AND public.is_admin_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

-- inventory_turnover_report_items
alter table public.inventory_turnover_report_items enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read inventory items'
          AND schemaname = 'public'
          AND tablename = 'inventory_turnover_report_items'
    ) THEN
        CREATE POLICY "Allow members to read inventory items"
        ON public.inventory_turnover_report_items
        FOR SELECT
        USING (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = inventory_turnover_report_items.report_id
              AND public.is_member_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow admins to manage inventory items'
          AND schemaname = 'public'
          AND tablename = 'inventory_turnover_report_items'
    ) THEN
        CREATE POLICY "Allow admins to manage inventory items"
        ON public.inventory_turnover_report_items
        FOR ALL
        WITH CHECK (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = inventory_turnover_report_items.report_id
              AND public.is_admin_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

-- plan_fact_reports_items
alter table public.plan_fact_reports_items enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read plan-fact items'
          AND schemaname = 'public'
          AND tablename = 'plan_fact_reports_items'
    ) THEN
        CREATE POLICY "Allow members to read plan-fact items"
        ON public.plan_fact_reports_items
        FOR SELECT
        USING (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = plan_fact_reports_items.report_id
              AND public.is_member_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow admins to manage plan-fact items'
          AND schemaname = 'public'
          AND tablename = 'plan_fact_reports_items'
    ) THEN
        CREATE POLICY "Allow admins to manage plan-fact items"
        ON public.plan_fact_reports_items
        FOR ALL
        WITH CHECK (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = plan_fact_reports_items.report_id
              AND public.is_admin_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

-- debt_reports_items
alter table public.debt_reports_items enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read debt items'
          AND schemaname = 'public'
          AND tablename = 'debt_reports_items'
    ) THEN
        CREATE POLICY "Allow members to read debt items"
        ON public.debt_reports_items
        FOR SELECT
        USING (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = debt_reports_items.report_id
              AND public.is_member_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow admins to manage debt items'
          AND schemaname = 'public'
          AND tablename = 'debt_reports_items'
    ) THEN
        CREATE POLICY "Allow admins to manage debt items"
        ON public.debt_reports_items
        FOR ALL
        WITH CHECK (EXISTS (
            SELECT 1
            FROM public.report_metadata rm
            WHERE rm.id = debt_reports_items.report_id
              AND public.is_admin_of(rm.organization_id, auth.uid())
        ));
    END IF;
END
$$;

-- summary tables (read-only)
alter table public.cash_bank_monthly_summaries enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read monthly summaries'
          AND schemaname = 'public'
          AND tablename = 'cash_bank_monthly_summaries'
    ) THEN
        CREATE POLICY "Allow members to read monthly summaries"
        ON public.cash_bank_monthly_summaries
        FOR SELECT
        USING (public.is_member_of(organization_id, auth.uid()));
    END IF;
END
$$;

alter table public.inventory_monthly_summaries enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read inventory summaries'
          AND schemaname = 'public'
          AND tablename = 'inventory_monthly_summaries'
    ) THEN
        CREATE POLICY "Allow members to read inventory summaries"
        ON public.inventory_monthly_summaries
        FOR SELECT
        USING (public.is_member_of(organization_id, auth.uid()));
    END IF;
END
$$;

alter table public.debt_monthly_summaries enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read debt summaries'
          AND schemaname = 'public'
          AND tablename = 'debt_monthly_summaries'
    ) THEN
        CREATE POLICY "Allow members to read debt summaries"
        ON public.debt_monthly_summaries
        FOR SELECT
        USING (public.is_member_of(organization_id, auth.uid()));
    END IF;
END
$$;

alter table public.plan_fact_monthly_summaries enable row level security;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Allow members to read plan-fact summaries'
          AND schemaname = 'public'
          AND tablename = 'plan_fact_monthly_summaries'
    ) THEN
        CREATE POLICY "Allow members to read plan-fact summaries"
        ON public.plan_fact_monthly_summaries
        FOR SELECT
        USING (public.is_member_of(organization_id, auth.uid()));
    END IF;
END
$$;

-- =============================================================
-- 6) ТРИГГЕРЫ И СВЯЗАННЫЕ ФУНКЦИИ
-- -------------------------------------------------------------
-- - set_first_member_as_admin(): назначить первого участника админом.
-- - update_report_metadata_timestamp(): автообновление updated_at.
-- - handle_user_widget_settings_update(): обновление updated_at при UPDATE.
-- =============================================================

create or replace function public.set_first_member_as_admin()
returns trigger language plpgsql security definer as $$
begin
    if (select count(*) from public.organization_members where organization_id = new.organization_id) = 1 then
        update public.organization_members set role = 'admin' where id = new.id;
    end if;
    return new;
end;
$$;

drop trigger if exists on_new_member_set_admin_role on public.organization_members;
create trigger on_new_member_set_admin_role
after insert on public.organization_members
for each row execute function public.set_first_member_as_admin();

create or replace function public.update_report_metadata_timestamp()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql;

drop trigger if exists update_report_metadata_timestamp on public.report_metadata;
create trigger update_report_metadata_timestamp
before update on public.report_metadata
for each row execute function public.update_report_metadata_timestamp();

create or replace function public.handle_user_widget_settings_update()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql;

-- триггер создадим после таблицы user_widget_settings (см. раздел 7)

-- =============================================================
-- 7) ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ ВИДЖЕТОВ (таблица + функции)
-- -------------------------------------------------------------
-- user_widget_settings         — видимость и порядок виджетов на дашборде.
-- get_user_widget_settings()   — чтение с учётом значений по умолчанию.
-- save_widget_order(jsonb)     — сохранение пользовательского порядка.
-- =============================================================


-- 1) Таблица
create table if not exists public.user_widget_settings (
    user_id uuid not null references auth.users(id) on delete cascade,
    widget_id text not null,
    is_visible boolean not null default true,
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    widget_order int not null default 0,
    primary key (user_id, widget_id)
);

-- 2) Включаем RLS
alter table public.user_widget_settings enable row level security;

-- 3) Политика: пользователь управляет только своими записями
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies
        WHERE policyname = 'Users can manage their own widget settings'
          AND schemaname = 'public'
          AND tablename = 'user_widget_settings'
    ) THEN
        CREATE POLICY "Users can manage their own widget settings"
        ON public.user_widget_settings
        FOR ALL
        USING (auth.uid() = user_id)
        WITH CHECK (auth.uid() = user_id);
    END IF;
END
$$;

-- 4) Триггер для updated_at
create or replace function public.handle_user_widget_settings_update()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql;

drop trigger if exists on_user_widget_settings_update on public.user_widget_settings;
create trigger on_user_widget_settings_update
before update on public.user_widget_settings
for each row
execute function public.handle_user_widget_settings_update();

-- 5) Функция: вернуть список виджетов с дефолтным порядком
create or replace function public.get_user_widget_settings()
returns table(widget_id text, is_visible boolean, widget_order int)
language plpgsql
as $$
declare
    v_user_id uuid := auth.uid();
begin
    -- Единый перечень доступных виджетов и их дефолтный порядок.
    return query
    with default_widgets (id, "order") as (
        values
            ('cash_bank', 0),
            ('debt', 1),
            ('plan_fact', 2),
            ('inventory', 3)
    )
    select
        dw.id,
        coalesce(uws.is_visible, true) as is_visible,
        coalesce(uws.widget_order, dw."order") as widget_order
    from default_widgets dw
    left join public.user_widget_settings uws
      on uws.widget_id = dw.id and uws.user_id = v_user_id
    order by widget_order;
end;
$$;

-- 6) Функция: сохранить порядок виджетов
create or replace function public.save_widget_order(p_widget_orders jsonb)
returns void
language plpgsql
as $$
declare
    widget_data jsonb;
    v_user_id uuid := auth.uid();
begin
    for widget_data in select * from jsonb_array_elements(p_widget_orders)
    loop
        insert into public.user_widget_settings (user_id, widget_id, widget_order)
        values (
            v_user_id,
            widget_data->>'widget_id',
            (widget_data->>'order')::int
        )
        on conflict (user_id, widget_id)
        do update set
            widget_order = excluded.widget_order,
            updated_at = now();
    end loop;
end;
$$;


-- =============================================================
-- 8) RPC-ФУНКЦИИ ПРИЛОЖЕНИЙ (ОРГАНИЗАЦИИ, ЗАГРУЗКИ ОТЧЁТОВ)
-- -------------------------------------------------------------
-- get_organization_members()         — список участников с email.
-- invite_user_to_organization()      — приглашение по e-mail.
-- create_organization_and_add_creator() — создать организацию и добавить создателя.
-- upsert_*_report()                  — загрузка отчётов (обновление по дате).
-- match_documents()                  — поиск в RAG-хранилище.
-- =============================================================

create or replace function public.get_organization_members(p_organization_id uuid)
returns table (
  member_id bigint,
  user_id uuid,
  organization_id uuid,
  role text,
  email text
)
language plpgsql
security definer
as $$
begin
    if not public.is_member_of(p_organization_id, auth.uid()) then
        raise exception 'Access denied: You are not a member of this organization.';
    end if;

    return query
    select
        om.id as member_id,
        om.user_id,
        om.organization_id,
        om.role,
        u.email::text as email
    from public.organization_members om
    join auth.users u on om.user_id = u.id
    where om.organization_id = p_organization_id
    order by u.email;
end;
$$;

create or replace function public.invite_user_to_organization(p_organization_id uuid, p_invitee_email text)
returns void language plpgsql security definer as $$
declare
    v_invitee_user_id uuid;
begin
    select id into v_invitee_user_id from auth.users where lower(email) = lower(p_invitee_email);

    if v_invitee_user_id is null then
        raise exception 'User with email % not found. Please ask them to sign up first.', p_invitee_email;
    end if;

    insert into public.organization_members (organization_id, user_id, role)
    values (p_organization_id, v_invitee_user_id, 'member');
end;
$$;

create or replace function public.create_organization_and_add_creator(p_org_name text)
returns uuid language plpgsql security invoker as $$
declare
    v_org_id uuid;
    v_user_id uuid := auth.uid();
begin
    insert into public.organizations (name) values (p_org_name)
    returning id into v_org_id;

    insert into public.organization_members (organization_id, user_id, role)
    values (v_org_id, v_user_id, 'member');

    return v_org_id;
end;
$$;

-- Поиск по эмбеддингам (RAG)
create or replace function public.match_documents (query_embedding vector(1024), match_count int default null, filter jsonb default '{}')
returns table (id bigint, content text, metadata jsonb, similarity float)
language sql as $$
  select d.id, d.content, d.metadata, 1 - (d.embedding <=> query_embedding) as similarity
  from public.documents d
  where d.metadata @> filter
  order by d.embedding <=> query_embedding
  limit match_count;
$$;

-- Upsert: Cash & Bank
create or replace function public.upsert_cash_bank_report(p_organization_name text, p_report_date date, p_report_items jsonb)
returns uuid language plpgsql security definer as $$
declare
    v_organization_id uuid;
    v_report_id uuid;
    item jsonb;
    v_item_id uuid;
    v_parent_id uuid;
begin
    insert into public.organizations (name) values (p_organization_name)
    on conflict (name) do update set name = excluded.name
    returning id into v_organization_id;

    insert into public.report_metadata (organization_id, report_type, report_date, updated_at)
    values (v_organization_id, 'cash_bank', p_report_date, now())
    on conflict (organization_id, report_type, report_date) do update set updated_at = now()
    returning id into v_report_id;

    delete from public.cash_bank_report_items where report_id = v_report_id;

    create temp table temp_id_map (account_id text primary key, item_id uuid not null) on commit drop;

    for item in select * from jsonb_array_elements(p_report_items) loop
        insert into public.cash_bank_report_items (
            report_id, account_id, parent_account_id, account_name, subconto,
            balance_start, income_amount, expense_amount, balance_current,
            account_type, level, currency, is_total_row, parent_id
        ) values (
            v_report_id, item->>'account_id', item->>'parent_account_id', item->>'account_name', item->>'subconto',
            (item->>'balance_start')::decimal(15,2), (item->>'income_amount')::decimal(15,2),
            (item->>'expense_amount')::decimal(15,2), (item->>'balance_current')::decimal(15,2),
            item->>'account_type', (item->>'level')::integer, item->>'currency', coalesce((item->>'is_total_row')::boolean, false), null
        ) returning id into v_item_id;

        if item->>'account_id' is not null and trim(item->>'account_id') != '' then
            insert into temp_id_map (account_id, item_id)
            values (item->>'account_id', v_item_id)
            on conflict (account_id) do nothing;
        end if;
    end loop;

    for item in select * from jsonb_array_elements(p_report_items) loop
        if item->>'parent_account_id' is not null and trim(item->>'parent_account_id') != '' then
            select item_id into v_parent_id from temp_id_map where account_id = item->>'parent_account_id';
            if v_parent_id is not null then
                update public.cash_bank_report_items set parent_id = v_parent_id
                where report_id = v_report_id and account_id = item->>'account_id';
            end if;
        end if;
    end loop;

    return v_report_id;
end;
$$;

-- Upsert: Inventory Turnover (версия с поддержкой is_total_row)
create or replace function public.upsert_inventory_turnover_report(p_organization_name text, p_report_date date, p_report_items jsonb)
returns uuid language plpgsql security definer as $$
declare
    v_organization_id uuid;
    v_report_id uuid;
    item jsonb;
    v_item_id uuid;
    v_parent_id uuid;
begin
    insert into public.organizations (name) values (p_organization_name)
    on conflict (name) do update set name = excluded.name
    returning id into v_organization_id;

    insert into public.report_metadata (organization_id, report_type, report_date, updated_at)
    values (v_organization_id, 'inventory_turnover', p_report_date, now())
    on conflict (organization_id, report_type, report_date) do update set updated_at = now()
    returning id into v_report_id;

    delete from public.inventory_turnover_report_items where report_id = v_report_id;

    create temp table temp_category_map (category_name text primary key, item_id uuid not null) on commit drop;

    for item in select * from jsonb_array_elements(p_report_items) loop
        insert into public.inventory_turnover_report_items (
            report_id, category_name, quantity_pairs, balance_rub, dynamics_start_month_rub,
            dynamics_start_month_percent, dynamics_start_year_rub, dynamics_start_year_percent,
            turnover_days, level, is_total_row
        ) values (
            v_report_id,
            item->>'category_name',
            (item->>'quantity_pairs')::integer,
            (item->>'balance_rub')::decimal,
            (item->>'dynamics_start_month_rub')::decimal,
            (item->>'dynamics_start_month_percent')::decimal,
            (item->>'dynamics_start_year_rub')::decimal,
            (item->>'dynamics_start_year_percent')::decimal,
            (item->>'turnover_days')::integer,
            (item->>'level')::integer,
            coalesce((item->>'is_total_row')::boolean, false)
        ) returning id into v_item_id;

        insert into temp_category_map (category_name, item_id) values (item->>'category_name', v_item_id);
    end loop;

    for item in select * from jsonb_array_elements(p_report_items) loop
        if item->>'parent_category_name' is not null and item->>'parent_category_name' != '' then
            select item_id into v_parent_id from temp_category_map where category_name = item->>'parent_category_name';
            if v_parent_id is not null then
                update public.inventory_turnover_report_items set parent_category_id = v_parent_id
                where report_id = v_report_id and category_name = item->>'category_name';
            end if;
        end if;
    end loop;

    return v_report_id;
end;
$$;

-- Upsert: План-факт
create or replace function public.upsert_plan_fact_report(p_organization_name text, p_report_date date, p_report_items jsonb)
returns uuid language plpgsql security definer as $$
declare
    v_organization_id uuid;
    v_report_id uuid;
    item jsonb;
    v_item_id uuid;
    v_parent_id uuid;
begin
    insert into public.organizations (name) values (p_organization_name)
    on conflict (name) do update set name = excluded.name
    returning id into v_organization_id;

    insert into public.report_metadata (organization_id, report_type, report_date, updated_at)
    values (v_organization_id, 'plan_fact', p_report_date, now())
    on conflict (organization_id, report_type, report_date) do update set updated_at = now()
    returning id into v_report_id;

    delete from public.plan_fact_reports_items where report_id = v_report_id;

    create temp table temp_category_map (category_name text primary key, item_id uuid not null) on commit drop;

    for item in select * from jsonb_array_elements(p_report_items) loop
        insert into public.plan_fact_reports_items (
            report_id, category_name, plan_amount, fact_amount, execution_percent,
            is_total_row, period_type, level, is_expandable
        ) values (
            v_report_id, item->>'category_name', (item->>'plan_amount')::decimal, (item->>'fact_amount')::decimal,
            (item->>'execution_percent')::decimal, coalesce((item->>'is_total_row')::boolean, false), item->>'period_type',
            (item->>'level')::integer, coalesce((item->>'is_expandable')::boolean, false)
        ) returning id into v_item_id;

        insert into temp_category_map (category_name, item_id) values (item->>'category_name', v_item_id);
    end loop;

    for item in select * from jsonb_array_elements(p_report_items) loop
        if item->>'parent_category_name' is not null and item->>'parent_category_name' != '' then
            select item_id into v_parent_id from temp_category_map where category_name = item->>'parent_category_name';
            if v_parent_id is not null then
                update public.plan_fact_reports_items set parent_id = v_parent_id
                where report_id = v_report_id and category_name = item->>'category_name';
            end if;
        end if;
    end loop;

    return v_report_id;
end;
$$;

-- =============================================================
-- 9) ФУНКЦИИ ДЛЯ ДАШБОРДА (СВОДКИ И ДИНАМИКА)
-- -------------------------------------------------------------
-- get_cash_bank_dashboard_summary(date)  — сумма итоговых остатков на дату.
-- get_debt_dashboard_summary(date)       — суммарные debt/overdue/credit.
-- get_plan_fact_dashboard_summary(date)  — суммарный план/факт и % выполнения.
-- get_inventory_dashboard_summary(date)  — суммарные запасы и кол-во пар.
-- get_cash_flow_dynamics(ids[], d1, d2)  — динамика денежных средств по дням.
-- get_dashboard_widget_data(...)         — единая сборка под тип виджета.
-- =============================================================

create or replace function public.get_cash_bank_dashboard_summary(p_report_date date)
returns table(total_balance_current numeric)
language plpgsql
security definer
as $$
declare
    v_user_id uuid := auth.uid();
begin
    return query
    select
        sum(cbri.balance_current) as total_balance_current
    from public.cash_bank_report_items as cbri
    join public.report_metadata as rm on cbri.report_id = rm.id
    where rm.report_date = p_report_date
      and cbri.is_total_row = true
      and rm.organization_id in (
          select om.organization_id from public.organization_members om where om.user_id = v_user_id
      );
end;
$$;

create or replace function public.get_debt_dashboard_summary(p_report_date date)
returns table(total_debt numeric, total_overdue numeric, total_credit numeric)
language plpgsql
security definer
as $$
declare
    v_user_id uuid := auth.uid();
begin
    return query
    select
        sum(dri.debt_amount) as total_debt,
        sum(dri.overdue_amount) as total_overdue,
        sum(dri.credit_amount) as total_credit
    from public.debt_reports_items as dri
    join public.report_metadata as rm on dri.report_id = rm.id
    where rm.report_date = p_report_date
      and dri.is_total_row = true
      and rm.organization_id in (
          select om.organization_id from public.organization_members om where om.user_id = v_user_id
      );
end;
$$;

create or replace function public.get_plan_fact_dashboard_summary(p_report_date date)
returns table(total_plan numeric, total_fact numeric, overall_execution_percent numeric)
language plpgsql
security definer
as $$
declare
    v_user_id uuid := auth.uid();
    v_total_plan numeric;
    v_total_fact numeric;
begin
    select
        sum(pfri.plan_amount),
        sum(pfri.fact_amount)
    into v_total_plan, v_total_fact
    from public.plan_fact_reports_items as pfri
    join public.report_metadata as rm on pfri.report_id = rm.id
    where rm.report_date = p_report_date
      and pfri.is_total_row = true
      and rm.organization_id in (
          select om.organization_id from public.organization_members om where om.user_id = v_user_id
      );

    return query
    select
        coalesce(v_total_plan, 0) as total_plan,
        coalesce(v_total_fact, 0) as total_fact,
        case
            when v_total_plan is not null and v_total_plan > 0 then (v_total_fact / v_total_plan) * 100
            else 0
        end as overall_execution_percent;
end;
$$;

create or replace function public.get_inventory_dashboard_summary(p_report_date date)
returns table(total_balance_rub numeric, total_quantity_pairs bigint)
language plpgsql
security definer
as $$
declare
    v_user_id uuid := auth.uid();
begin
    return query
    select
        sum(itri.balance_rub) as total_balance_rub,
        sum(itri.quantity_pairs)::bigint as total_quantity_pairs
    from public.inventory_turnover_report_items as itri
    join public.report_metadata as rm on itri.report_id = rm.id
    where rm.report_date = p_report_date
      and itri.is_total_row = true
      and rm.organization_id in (
          select om.organization_id from public.organization_members om where om.user_id = v_user_id
      );
end;
$$;

-- Динамика денежных средств по дням для выбранных организаций
create or replace function public.get_cash_flow_dynamics(
    p_organization_ids uuid[],
    p_start_date date,
    p_end_date date
)
returns table(report_day date, total_balance numeric)
language plpgsql
security definer
as $$
begin
    return query
    select
        rm.report_date as report_day,
        sum(cbri.balance_current) as total_balance
    from public.cash_bank_report_items as cbri
    join public.report_metadata as rm on cbri.report_id = rm.id
    where
        rm.organization_id = any(p_organization_ids)
        and rm.report_date >= p_start_date
        and rm.report_date <= p_end_date
        and cbri.is_total_row = true
    group by rm.report_date
    order by rm.report_date asc;
end;
$$;

-- Универсальная функция для данных виджета (исправлен тип отчёта 'inventory')
create or replace function public.get_dashboard_widget_data(
    p_widget_type text,
    p_report_date date,
    p_organization_ids uuid[]
)
returns json
language plpgsql
as $$
declare
    current_report_ids uuid[];
    previous_report_ids uuid[];
    result_json json;
    v_report_type text;
begin
    -- Мэппинг типа виджета в тип отчёта в report_metadata
    v_report_type := case p_widget_type
        when 'inventory' then 'inventory_turnover'
        else p_widget_type
    end;

    -- Найти последние отчёты на указанную дату по каждой организации
    with latest_reports as (
        select distinct on (organization_id) id
        from report_metadata
        where organization_id = any(p_organization_ids)
          and report_type = v_report_type
          and report_date <= p_report_date
        order by organization_id, report_date desc
    )
    select array_agg(id) into current_report_ids from latest_reports;

    -- Найти последние отчёты на предыдущий день
    with latest_reports_prev as (
        select distinct on (organization_id) id
        from report_metadata
        where organization_id = any(p_organization_ids)
          and report_type = v_report_type
          and report_date <= (p_report_date - interval '1 day')
        order by organization_id, report_date desc
    )
    select array_agg(id) into previous_report_ids from latest_reports_prev;

    case p_widget_type
        when 'cash_bank' then
            select json_build_object(
                'total_balance_current', current_data.total,
                'change_percent', case 
                                    when prev_data.total <> 0 then ((current_data.total - prev_data.total) / prev_data.total) * 100 
                                    when current_data.total <> 0 then 100
                                    else 0 
                                  end
            )
            into result_json
            from 
                (select coalesce(sum(balance_current), 0) as total from cash_bank_report_items where report_id = any(current_report_ids) and is_total_row = true) as current_data,
                (select coalesce(sum(balance_current), 0) as total from cash_bank_report_items where report_id = any(previous_report_ids) and is_total_row = true) as prev_data;

        when 'debt' then
            select json_build_object(
                'total_debt', current_data.total,
                'change_percent', case 
                                    when prev_data.total <> 0 then ((current_data.total - prev_data.total) / prev_data.total) * 100 
                                    when current_data.total <> 0 then 100
                                    else 0 
                                  end
            )
            into result_json
            from 
                (select coalesce(sum(debt_amount), 0) as total from debt_reports_items where report_id = any(current_report_ids) and is_total_row = true) as current_data,
                (select coalesce(sum(debt_amount), 0) as total from debt_reports_items where report_id = any(previous_report_ids) and is_total_row = true) as prev_data;

        when 'inventory' then
            select json_build_object(
                'total_balance_rub', current_data.total,
                'change_percent', case 
                                    when prev_data.total <> 0 then ((current_data.total - prev_data.total) / prev_data.total) * 100 
                                    when current_data.total <> 0 then 100
                                    else 0 
                                  end
            )
            into result_json
            from 
                (select coalesce(sum(balance_rub), 0) as total from inventory_turnover_report_items where report_id = any(current_report_ids) and is_total_row = true) as current_data,
                (select coalesce(sum(balance_rub), 0) as total from inventory_turnover_report_items where report_id = any(previous_report_ids) and is_total_row = true) as prev_data;

        when 'plan_fact' then
            select json_build_object(
                'overall_execution_percent', current_data.percent,
                'change_percent', current_data.percent - prev_data.percent
            )
            into result_json
            from
                (select case when sum(plan_amount) > 0 then (sum(fact_amount) / sum(plan_amount)) * 100 else 0 end as percent from plan_fact_reports_items where report_id = any(current_report_ids) and is_total_row = true and period_type = 'month') as current_data,
                (select case when sum(plan_amount) > 0 then (sum(fact_amount) / sum(plan_amount)) * 100 else 0 end as percent from plan_fact_reports_items where report_id = any(previous_report_ids) and is_total_row = true and period_type = 'month') as prev_data;
        else
            result_json := '{}'::json;
    end case;

    return coalesce(result_json, '{}'::json);
end;
$$;
