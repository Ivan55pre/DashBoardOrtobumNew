// Вспомогательная функция для преобразования древовидной структуры в плоский список
function flattenTree(nodes, parentAccountId = null) {
  let flatList = [];
  if (!Array.isArray(nodes)) {
    // Если на вход пришел не массив, возвращаем пустой список
    return [];
  }
  nodes.forEach(node => {
    const { children, ...item } = node;
    
    // Добавляем текущий элемент в список, проставляя ID родителя
    const flatItem = { ...item, parent_account_id: parentAccountId };
    flatList.push(flatItem);

    // Если есть дочерние элементы, рекурсивно обрабатываем их
    if (children && children.length > 0) {
      flatList = flatList.concat(flattenTree(children, item.account_id));
    }
  });
  return flatList;
}

// Получаем все элементы, пришедшие от предыдущего узла (HTTP Request)
const allJsons = items.map(item => item.json);
const allItems = allJsons.flatMap(obj => obj.body || []);

// Группируем элементы по organization_name
const groupedItems = allItems.reduce((groups, item) => {
  const organization = item.organization_name;

  if (!groups[organization]) {
    groups[organization] = [];
  }
  groups[organization].push(item);
  return groups;
}, {});

// Формируем выходные данные для каждого уникального отчета
const output = Object.entries(groupedItems).map(([organization, treeItems]) => {
  // Берем reportDate из первого элемента группы, если есть, иначе используем текущую дату
  const reportDate = treeItems[0].reportDate || new Date().toISOString().split('T')[0];

  // Преобразуем дерево в плоский список, который ожидает SQL-функция
  const flatItems = flattenTree(treeItems);

  const reportItems = flatItems.map(item => {
    let accountType = 'bank';
    const accountName = (item.account_name || '').toLowerCase();

    if (item.is_total_row) {
      accountType = 'total';
    } else if (accountName.includes('касса') || accountName.includes('cash')) {
      accountType = 'cash';
    } else if (!accountName) {
      accountType = 'total';
    }

    return {
      account_name: item.account_name,
      subconto: item.subconto || null,
      balance_start: parseFloat(item.СуммаНачальныйОстаток) || 0,
      income_amount: parseFloat(item.СуммаОборотДт) || 0,
      expense_amount: parseFloat(item.СуммаОборотКт) || 0,
      balance_current: parseFloat(item.СуммаКонечныйОстаток) || 0,
      account_type: accountType,
      level: parseInt(item.level || item.Уровень || 1, 10),
      currency: item.currency || 'RUB',
      is_total_row: Boolean(item.is_total_row),
      account_id: item.account_id || null,
      parent_account_id: item.parent_account_id || null
    };
  });

  return {
    json: {
      query: 'SELECT public.upsert_cash_bank_report($1, $2, $3::jsonb)',
      params: [
        organization,
        reportDate,
        JSON.stringify(reportItems)
      ],
      status: 'ready_for_postgres'
    }
  };
});

return output;