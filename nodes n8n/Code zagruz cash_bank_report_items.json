// Helper function to flatten a tree structure, generate parent-child IDs,
// and filter out the special root node.
function flattenAndProcess(nodes, parentId = null) {
  let flatList = [];
  if (!nodes || !Array.isArray(nodes)) {
    return flatList;
  }

  for (const node of nodes) {
    // Use 'НомерПоПорядку' as the unique identifier for the current node.
    const currentId = node.НомерПоПорядку ? String(node.НомерПоПорядку) : null;

    // Check if the current node is the special root node.
    const isRootNode = node.Организация === null && node.organization_name === 'Всеорганизации';

    // Add the node to the list unless it's the special root node.
    if (!isRootNode) {
      const newItem = {
        ...node,
        account_id: currentId,
        parent_account_id: parentId ? String(parentId) : null,
      };
      flatList.push(newItem);
    }
    
    // Recursively process children (now named 'Строки').
    if (node.Строки && node.Строки.length > 0) {
      // If the current node was the root, its children have no parent (parentId = null).
      // Otherwise, they inherit the current node's ID as their parent.
      const childsParentId = isRootNode ? null : currentId;
      flatList = flatList.concat(flattenAndProcess(node.Строки, childsParentId));
    }
  }
  return flatList;
}


// --- Main Logic ---

// 1. Get the root nodes from the input. The input is now a tree.
const rootNodes = items.flatMap(item => item.json.body || []);

// 2. Flatten the tree(s) into a list of items.
// This function also generates `account_id` and `parent_account_id` and filters the root.
const allItems = flattenAndProcess(rootNodes);

// 3. Group the flat items by 'organization_name'.
const groupedItems = allItems.reduce((groups, item) => {
  const organization = item.organization_name;

  // Skip items that don't have an organization name.
  if (!organization) {
    return groups;
  }

  if (!groups[organization]) {
    groups[organization] = [];
  }
  groups[organization].push(item);
  return groups;
}, {});

// 4. For each organization, create a database query payload.
const output = Object.entries(groupedItems).map(([organization, orgItems]) => {
  // Use the reportDate from the first item, or default to today.
  const reportDate = orgItems[0].reportDate || new Date().toISOString().split('T')[0];

  const reportItems = orgItems.map(item => {
    let accountType = 'bank'; // Default account type
    const accountName = (item.account_name || '').toLowerCase();

    if (item.is_total_row) {
      accountType = 'total';
    } else if (accountName.includes('касса') || accountName.includes('cash')) {
      accountType = 'cash';
    } else if (!accountName) {
      // This handles grouping rows that are not explicitly 'total' rows.
      // Per original logic, they are marked as 'total'.
      accountType = 'total';
    }

    return {
      account_name: item.account_name,
      subconto: item.subconto || null,
      balance_start: parseFloat(item.СуммаНачальныйОстаток) || 0,
      income_amount: parseFloat(item.СуммаОборотДт) || 0,
      expense_amount: parseFloat(item.СуммаОборотКт) || 0,
      balance_current: parseFloat(item.СуммаКонечныйОстаток) || 0,
      account_type: accountType,
      level: parseInt(item.level || item.Уровень || 1, 10),
      currency: item.currency || 'RUB',
      is_total_row: Boolean(item.is_total_row),
      // These IDs are generated by the flattenAndProcess function.
      account_id: item.account_id,
      parent_account_id: item.parent_account_id
    };
  });

  return {
    json: {
      query: 'SELECT public.upsert_cash_bank_report($1, $2, $3::jsonb)',
      params: [
        organization,
        reportDate,
        JSON.stringify(reportItems)
      ],
      status: 'ready_for_postgres'
    }
  };
});

return output;