// ===== helpers =====
function toFloat(x){ const n = parseFloat(String(x ?? '').toString().replace(',', '.')); return isFinite(n) ? n : 0; }
function toInt(x, d=1){ const n = parseInt(x ?? d, 10); return Number.isFinite(n) ? n : d; }

function classifyAccountType(item){
  const name = (item.account_name || '').toLowerCase();
  if (item.is_total_row) return 'total';
  if (!name) return 'total';
  if (name.includes('касса') || name.includes('cash')) return 'cash';
  return 'bank';
}

// ====== МИНИМАЛЬНО ИЗМЕНЁННАЯ версия flattenTree ======
// Было: работала по полю children и переносила входные account_id/parent_account_id.
// Стало: читаем детей из "Строки"; генерируем синтетические account_id и parent_account_id;
//         дополнительно собираем path / path_names.
function flattenTree(nodes, parentAccountId = null, state = { seq: 0 }, parentPathNames = []) {
  let flatList = [];
  if (!Array.isArray(nodes)) return [];

  nodes.forEach(node => {
    // отделим детей как раньше, но поле теперь "Строки"
    const { Строки: children, ...item } = node;

    // синтетический account_id
    const account_id = ++state.seq;

    // нормализуем уровень
    const level = toInt(item.level ?? item['Уровень'] ?? 1);

    // имя для пути
    const account_name = item.account_name ?? item['ПечСубконто1БанкСчет'] ?? null;
    const path_names = [...parentPathNames, account_name].filter(Boolean);
    const path = path_names.join(' / '); // человекочитаемый путь

    // собираем плоский элемент (минимально меняем остальной код)
    const flatItem = {
      ...item,
      account_id,
      parent_account_id: parentAccountId,
      // нормализованные поля:
      level,
      account_name,
      // полезно для UI/проверок:
      path,
      path_names
    };
    flatList.push(flatItem);

    // рекурсия по детям из "Строки"
    const kids = Array.isArray(children) ? children : [];
    if (kids.length) {
      flatList = flatList.concat(
        flattenTree(kids, account_id, state, path_names)
      );
    }
  });

  return flatList;
}

// ===== основной код узла =====
const allJsons = items.map(item => item.json);
const allItems = allJsons.flatMap(obj => obj.body || []);

// группируем по organization_name
const groupedItems = allItems.reduce((groups, item) => {
  const organization = item.organization_name;
  (groups[organization] ||= []).push(item);
  return groups;
}, {});

const output = Object.entries(groupedItems).map(([organization, treeItems]) => {
  const reportDate = treeItems[0].reportDate || new Date().toISOString().split('T')[0];

  // ВАЖНО: теперь flattenTree читает "Строки" и генерирует account_id/parent_account_id
  const flatItems = flattenTree(treeItems);

  const reportItems = flatItems.map(item => {
    const account_type = classifyAccountType(item);
    return {
      account_name: item.account_name,
      subconto: item.subconto || null,
      balance_start: toFloat(item['СуммаНачальныйОстаток']),
      income_amount: toFloat(item['СуммаОборотДт']),
      expense_amount: toFloat(item['СуммаОборотКт']),
      balance_current: toFloat(item['СуммаКонечныйОстаток']),
      account_type,
      level: toInt(item.level ?? item['Уровень'] ?? 1),
      currency: item.currency || 'RUB',
      is_total_row: Boolean(item.is_total_row),

      // синтетическая иерархия с прежними ИМЕНАМИ колонок:
      account_id: item.account_id,
      parent_account_id: item.parent_account_id,

      // «человеческие» пути:
      path: item.path,
      path_names: item.path_names
    };
  });

  return {
    json: {
      query: 'SELECT public.upsert_cash_bank_report($1, $2, $3::jsonb)',
      params: [organization, reportDate, JSON.stringify(reportItems)],
      status: 'ready_for_postgres'
    }
  };
});

return output;
